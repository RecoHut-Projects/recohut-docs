# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/models/models.itempop.ipynb (unless otherwise specified).

__all__ = ['ItemPop', 'ItemPop_v2']

# Cell
import pandas as pd
from itertools import islice, cycle
import operator

# Cell
class ItemPop():
    """
    Makes recommendations based on popular items
    """

    def __init__(self, max_K=10, days=30, item_column='item_id', user_column='user_id', dt_column='date', with_filter=False):
        self.max_K = max_K if not with_filter else 300
        self.days = days
        self.item_column = item_column
        self.user_column = user_column
        self.dt_column = dt_column
        self.recommendations = []

    def fit(self, df, ):
        min_date = df[self.dt_column].max().normalize() - pd.DateOffset(days=self.days)
        self.recommendations = df.loc[df[self.dt_column] > min_date,
                                      self.item_column].value_counts().head(self.max_K).index.values

    def recommend(self, users=None, N=10):
        recs = self.recommendations[:N]
        if users is None:
            return recs
        else:
            return list(islice(cycle([recs]), len(users)))

    def recommend_with_filter(self, train, user_ids, top_K=10):
        user_ids = pd.Series(user_ids)
        _users = user_ids[user_ids.isin(train[self.user_column])]
        new_users = user_ids[~user_ids.isin(_users)]
        full_recs = self.recommendations
        topk_recs = full_recs[:top_K]
        new_recs = pd.DataFrame({self.user_column: new_users})
        new_recs[self.item_column] = list(islice(cycle([topk_recs]), len(new_users)))
        _recs = pd.DataFrame({self.user_column: _users})
        _recs[self.item_column] = 0
        known_items = train.groupby(self.user_column)[self.item_column].apply(list).to_dict()
        _recs['additional_N'] = _recs[self.user_column].apply(
            lambda user_id: len(known_items[user_id]) if user_id in known_items else 0)
        _recs['total_N'] = _recs['additional_N'].apply(
            lambda add_N: add_N + top_K if add_N + top_K < len(full_recs) else len(full_recs))
        _recs['total_recs'] = _recs['total_N'].apply(
            lambda total_N: full_recs[:total_N])
        filter_func = lambda row: [item for item in row['total_recs']
                                   if item not in known_items[row[self.user_column]]][:top_K]
        _recs[self.item_column] = _recs.loc[:, ['total_recs', self.user_column]].apply(
            filter_func, axis=1)
        _recs = _recs[[self.user_column, self.item_column]]
        return pd.concat([new_recs, _recs], axis=0)

# Cell
class ItemPop_v2:
    """
    ItemPop_v2 simply recommends items ordered by their popularity
    in the training set.
    """
    def __init__(self):
        super().__init__()

    def fit(self, train_data, seq_col='sequence'):
        sequences = train_data[seq_col].values

        count_dict = {}
        for s in sequences:
            for item in s:
                if item not in count_dict:
                    count_dict[item] = 1
                else:
                    count_dict[item] += 1

        self.top = sorted(count_dict.items(), key=operator.itemgetter(1), reverse=True)
        self.top = [([x[0]], x[1]) for x in self.top]

    def recommend(self, user_profile, user_id=None):
        """
        Given the user profile return a list of recommendation
        :param user_profile: the user profile as a list of item identifiers
        :param user_id: (optional) the user id
        :return: list of recommendations e.g. [([2], 0.875), ([6], 1.0)]
        """
        return self.top

    def get_popular_list(self):
        return self.top

    @staticmethod
    def get_recommendation_list(recommendation):
        return list(map(lambda x: x[0], recommendation))

    @staticmethod
    def get_recommendation_confidence_list(recommendation):
        return list(map(lambda x: x[1], recommendation))