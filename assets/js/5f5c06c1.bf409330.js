"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6492],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(n),d=o,f=m["".concat(c,".").concat(d)]||m[d]||p[d]||a;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},96841:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return m}});var r=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],s={},c="MPNN",l={unversionedId:"models/mpnn",id:"models/mpnn",title:"MPNN",description:"Message Passing Neural Networks",source:"@site/docs/models/mpnn.mdx",sourceDirName:"models",slug:"/models/mpnn",permalink:"/docs/models/mpnn",editUrl:"https://github.com/recohut/docs/docs/docs/models/mpnn.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MMoE",permalink:"/docs/models/mmoe"},next:{title:"NeuMF",permalink:"/docs/models/neumf"}},u=[{value:"References",id:"references",children:[],level:2}],p={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"mpnn"},"MPNN"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Message Passing Neural Networks")),(0,a.kt)("p",null,"One of the first work on this topic was published by Duvenaud et al. (2015). He defined the model as a stack of differentiable layers where each layer is another round of passing the messages. He used the message passing architecture to extract valuable information from graph molecules and then transform it into a single feature vector. At that time, his work was groundbreaking because he made the architecture differentiable. It was de-facto one of the first convolutional neural network architectures that could operate on graphs."),(0,a.kt)("p",null,"Another attempt on this architecture was done by Li et al. (2016). Here, they focus on the sequential output from graphs, for example finding an optimal path in graph. To achieve that, they embedded GRU (Gated Recurrent Unit) into their algorithm."),(0,a.kt)("p",null,"Although these algorithms seem to be quite different, they have the same underlying concept in common which is a message passing between nodes in the graph. We will next see how those models can be combined into a single framework."),(0,a.kt)("figure",null,(0,a.kt)("p",null,(0,a.kt)("center",null,(0,a.kt)("img",{src:"https://github.com/recohut/graph-embeddings/raw/3ae14e9b7e26389dede9d33d96465a674b8acd21/docs/_images/L883045_1.png"}),(0,a.kt)("figcaption",null,"A very simple example of message passing architecture for node V1. In this case a message is a sum of neighbour\u2019s hidden states. The update function is an average between a message m and h1.")))),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://youtu.be/ijmxpItkRjc"},"Simple Message Passing on Graphs"))))}m.isMDXComponent=!0}}]);